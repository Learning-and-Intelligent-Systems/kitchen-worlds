#!/usr/bin/env python

from __future__ import print_function

import sys
import math
import argparse
import itertools
import shutil
import pickle
import os
import time
import random
import copy
import json
from os.path import join, abspath, dirname, isdir, isfile, basename

import einops

from config import EXP_PATH, OUTPUT_PATH
from itertools import product
from PIL import Image


# from pddlstream.language.constants import Equal, AND, print_solution, PDDLProblem
# from pddlstream.algorithms.meta import solve, create_parser

from pybullet_tools.utils import disconnect, LockRenderer, has_gui, WorldSaver, wait_if_gui, \
    SEPARATOR, get_aabb, wait_for_duration, has_gui, reset_simulation, set_random_seed, \
    set_numpy_seed, set_renderer
from pybullet_tools.bullet_utils import summarize_facts, print_goal, nice, get_datetime
from pybullet_tools.pr2_agent import solve_multiple, post_process, pddlstream_from_state_goal, \
    create_cwd_saver, solve_one
from pybullet_tools.pr2_primitives import control_commands, apply_commands
from pybullet_tools.logging import parallel_print, myprint

from lisdf_tools.lisdf_loader import pddl_files_from_dir

from world_builder.world import State
from world_builder.actions import apply_actions
from world_builder.world_generator import save_to_outputs_folder

from test_utils import parallel_processing, get_config
from test_world_builder import create_pybullet_world

from nsplan_tools.generate_semantic_specification import get_semantic_specs, get_semantic_spec
from nsplan_tools.utils.file import print_data_types

# additional dependencies for using streams
from pybullet_tools.bullet_utils import set_camera_target_body, visualize_camera_image, get_readable_list
from pybullet_planning.pybullet_tools.utils import get_image_at_pose, get_image, unit_pose, get_camera_matrix
import matplotlib.pyplot as plt
from world_builder.entities import StaticCamera
from world_builder.utils import parse_yaml
from pybullet_tools.pr2_primitives import Pose, Conf
from pybullet_tools.utils import get_pose, multiply, quat_from_euler, dump_world, get_bodies, remove_body, get_bodies, remove_body, invert, Euler, Point, pairwise_collisions, tform_from_pose
from pybullet_tools.flying_gripper_utils import get_se3_joints, se3_from_pose, Grasp, se3_ik
from world_builder.actions import get_primitive_actions

# gym-related
import gymnasium as gym
from gymnasium import error, spaces, utils
from gymnasium.utils import seeding
import numpy as np

# import env
from collect_clean_dish_rollouts import plot_images, CleanDishEnvV1


def get_goal_actions(symbolic_goal):
    # symbolic_goal = env.symbolic_goal
    goal_actions = []
    for obj_name in symbolic_goal:
        goal_actions.append(("place", obj_name, symbolic_goal[obj_name]))
    return goal_actions


def run_evaluation(args):
    env_config = parse_yaml(args.config_file)

    # override
    env_config.seed = args.seed
    env_config.semantic_spec_seed = args.semantic_spec_seed

    # change data.out_dir for storing evaluation data
    env_config.data.out_dir = os.path.join(os.path.split(env_config.data.out_dir)[0], "evaluation")
    print(f"Saving evaluation data to {abspath(env_config.data.out_dir)}")

    process(env_config)


def process(config):
    """ exist a version in cognitive-architectures for generating mini-datasets (single process),
        run in kitchen-worlds for parallelization, but no reliable planning time data

        inside each data folder, to be generated:
        - before planning:
            [x] scene.lisdf
            [x] problem.pddl
            [x] planning_config.json
            [x] log.txt (generated before planning)
        - after planning:
            [x] plan.json
            [x] commands.pkl
            [x] log.json (generated by pddlstream)
    """

    seed = config.seed
    semantic_spec_seed = config.semantic_spec_seed

    new_config = copy.deepcopy(config)
    new_config.seed = seed
    set_random_seed(seed)
    set_numpy_seed(seed)

    exp_dir = abspath(join(config.data.out_dir, "semantic_spec_{}_seed_{}".format(semantic_spec_seed, seed))) #+ get_datetime(TO_LISDF=True)))
    print(exp_dir)
    os.makedirs(exp_dir, exist_ok=True)
    new_config.data.out_dir = exp_dir

    new_config.world.builder_kwargs["semantic_spec_file"] = os.path.join(config.semantic_specs_dir, f"{semantic_spec_seed}.json")

    """ STEP 1 -- GENERATE SCENES """
    world, goal = create_pybullet_world(new_config, SAVE_LISDF=False, SAVE_TESTCASE=True)

    env = CleanDishEnvV1(world, goal, config, render_mode="bot")
    # input("env initialized, next?")
    # play(env)

    success_log_dir = os.path.split(config.data.out_dir)[0]
    success_log_file = os.path.join(success_log_dir, "success_log.txt")

    good_test_case = check_place_in_sink_feasibility(env)

    with open(success_log_file, "a") as fh:
        fh.write(f"semantic_spec_seed {semantic_spec_seed} seed {seed}: {good_test_case}\n")


def play(env):
    try:
        done = False
        obs = env.reset()
        num_moves = 0
        while not done:
            print("-"*10)
            print(f"move {num_moves}")
            env.print_admissible_actions()
            manip_name = input("manipulation name > ")
            obj_name = input("object name > ")
            loc_name = input("location name > ")
            action = env.convert_text_to_action(manip_name, obj_name, loc_name)
            obs, score, done, _, info = env.step(action)
            print(f"\nscore {score}, done {done}")
            num_moves += 1
    except KeyboardInterrupt:
        pass # Press the stop button in the toolbar to quit the game.

    print("\n" + "*" * 100)
    print("Played {} steps, scoring {} points.".format(num_moves, score))
    print("*" * 100 + "\n")


def check_place_in_sink_feasibility(env):



    good_test_case = True

    goal_actions = get_goal_actions(env.symbolic_goal)
    assert len(goal_actions) == 1
    goal_action = goal_actions[0]
    symbolic_state = env.symbolic_state

    # print(goal_action)

    goal_obj = goal_action[1]
    goal_obj_start_loc = symbolic_state[goal_obj]["location"]

    # text_actions = sorted(env.get_admissible_text_actions())
    # symbolic_feasible_text_actions = []
    # for text_action in text_actions:
    #     if env.check_symbolic_action_feasibility(text_action[0], text_action[1], text_action[2]):
    #         symbolic_feasible_text_actions.append(text_action)
    # print(f"{len(symbolic_feasible_text_actions)} symbolic feasible actions: {symbolic_feasible_text_actions}")

    action = env.convert_text_to_action("pick", goal_action[1], goal_obj_start_loc)
    obs, score, done, _, info = env.step(action)

    if score == -1:
        good_test_case = False

    action = env.convert_text_to_action("place", goal_action[1], goal_action[2])
    obs, score, done, _, info = env.step(action)

    if score == -1:
        good_test_case = False

    print(f"good test case: {good_test_case}")

    return good_test_case


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="collect rollouts")
    parser.add_argument("--seed", default=0, type=int)
    parser.add_argument("--semantic_spec_seed", default=2, type=int)
    parser.add_argument("--config_file", default='../configs/evaluate_clean_dish_feg_collect_rollouts_0922.yaml', type=str)
    args = parser.parse_args()

    run_evaluation(args)

